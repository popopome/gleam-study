# 레지스트리

[`singularity`](https://github.com/jhillyerd/singularity) 라이브러리를 기반으로 한 간단한 레지스트리 시스템입니다. Singularity의 핵심 기능들을 거의 그대로 가져와서 구현되었습니다.

## 왜 필요할까?

Gleam의 OTP 액터 시스템에서 다른 액터에게 메시지를 보내려면 해당 액터의 `Subject`를 직접 참조해야 합니다. 하지만 다음과 같은 문제점들이 있습니다:

1. **참조 관리의 어려움**: 액터의 `Subject`를 모든 관련 컴포넌트에서 개별적으로 주고받고 관리해야 하는 번거로움
2. **의존성 복잡성**: 여러 액터들이 서로의 `Subject`를 필요로 할 때, 이를 직접 전달하는 방식은 코드 구조를 복잡하게 만듦
3. **시작 순서 문제**: 액터가 시작되어야 다른 액터가 그 `Subject`를 사용할 수 있는데, 이를 동기화하기 어려움

레지스트리를 사용하면 이러한 문제를 해결할 수 있습니다:
- **중앙화된 관리**: 전역적으로 하나의 레지스트리 인스턴스를 운영하여, 필요할 때 액터 타입으로 `Subject`를 조회
- **편리한 접근**: `Subject`를到处 주렁주렁 전달할 필요 없이, 레지스트리에서 필요시점에 가져다 사용
- **의존성 처리**: 액터가 준비될 때까지 자동으로 대기하는 기능 제공

## 디자인 결정 및 제약사항

이 레지스트리 시스템은 **각 액터 타입당 하나의 싱글톤 인스턴스**만 등록하고 관리할 수 있도록 설계되었습니다.

### 허용되는 사용 사례:
- 한 애플리케이션 내에서 Database, Cache, Logger 등 서로 다른 타입의 액터들을 등록
- 각 타입의 액터는 하나씩만 존재하며, 글로벌하게 공유됨

### 제한되는 사용 사례:
- **같은 타입의 여러 액터 인스턴스**를 동시에 관리할 수 없음
- 예: 여러 개의 Worker 액터를 Worker1, Worker2, Worker3처럼 구분하여 관리 불가
- 이런 상황에서는 각각을 다른 variant 타입으로 정의하거나 별도의 관리 방식이 필요

이 제약은 Singularity가 의존성 관리와 OTP supervisor 패턴 구현을 목적으로 설계되었기 때문에 발생합니다. 동일 타입의 여러 인스턴스가 필요한 경우에는 풀(Pool)이나 supervisor등의 다른 관리 패턴을 적용해야 합니다.